"""Iteration tools"""

from collections import Sequence, deque
from collections.abc import Iterator
from itertools import islice
from functools import wraps
from copy import deepcopy


def flatten_list(lst):
    """Flatten an arbitrarily nested list (returns a generator)"""
    for el in lst:
        if isinstance(el, Sequence) and not isinstance(el, (str, bytes)):
            yield from flatten_list(el)
        else:
            yield el


def flatten_dict(pydict):
    """Flatten a dictionary

    Flatten a dictionary by generating a new dictionary containing all
    the keys from nested dictionaries. These keys are generated by
    concatenating the keys at different levels with the dot '.'
    character as the separator.

    """
    pydict = deepcopy(pydict)
    if not isinstance(pydict, dict):
        raise ValueError(f"Only dictionaries are supported: {type(pydict)}")
    children = {}
    for key, val in pydict.items():
        if isinstance(val, dict):
            children[key] = flatten_dict(pydict[key])
    for key, value in children.items():
        pydict.update([(".".join([key, k]), v) for k, v in value.items()])
        del pydict[key]
    return pydict


def intervals(iterable):
    """Iterator that returns two consecutive elements

    This iterator is useful when you want to look-ahead while
    iterating over a container.  If you want to look-back, just
    iterate over the reversed container.

    """
    for i in range(len(iterable) - 1):
        yield (iterable[i], iterable[i + 1])


class LookAheadItr(object):
    """Iterator that looks ahead.

    Iterating returns the current and the next value.  It is also accessible
    via the peek property of the iterator.

    """

    def __init__(self, itr):
        self.itr = itr
        self.exhausted = False
        self.__advance__()

    def __next__(self):
        if self.exhausted:
            raise StopIteration()
        cur = self.peek
        self.__advance__()
        return (cur, self.peek)

    def __advance__(self):
        try:
            self.peek = next(self.itr)
        except StopIteration:
            self.peek = None
            self.exhausted = True

    def __iter__(self):
        return self


class PeekingItr(object):
    """Iterator that remembers the previous value.

    This iterator iterates in two modes:
    1. iterating in pairs: (i_0, i_1), ... (i_{n-1}, i_n)

    >>> [(prev, cur) for prev, cur in PeekingItr(iter(range(5)), paired=True)]
    [(0, 1), (1, 2), (2, 3), (3, 4)]

    2. start iteration before the first element: (None, i_0), ... (i_{n-1}, i_n)

    >>> [(prev, cur) for prev, cur in PeekingItr(iter(range(5)), paired=False)]
    [(None, 0), (0, 1), (1, 2), (2, 3), (3, 4)]

    Each iteration returns the current and the previous value.  The current and
    previous values are also accessible via the 'cur' and 'prev' properties of
    the iterator.
    """

    def __init__(self, itr, paired=True):
        self.itr = itr if isinstance(itr, Iterator) else iter(itr)
        self.prev = None
        self.cur = next(self.itr) if paired else None

    def __next__(self):
        self.prev = self.cur
        self.cur = next(self.itr)
        return (self.prev, self.cur)

    def __iter__(self):
        return self


def consume(iterator, n=None):
    """Advance the iterator n-steps ahead. If n is None, consume entirely.

    source: "Itertools Recipes" in itertools docs
    """
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n), None)


def call_hook(hook):
    """Call the hook function"""
    try:
        hook[0](*hook[1:])
    except TypeError:
        print("Ignoring hook: {} is not a callable".format(hook[0]))


def iterate(recipe):
    """This decorator wraps a simulation recipe in loops.

    Recipes can iterate over a dataset exactly once (normal mode), or
    it can iterate over the same dataset over and over indefinitely
    (infinite mode).  In the latter case it essentially uses the
    dataset as a working area storing the latest state of the
    simulation.  In both scenarios, the iterable together with the
    index may be used to reference other items within the dataset.

    All recipes should at least accept the iterable, the current index
    and item as positional arguments respectively.  When running in
    'infinite mode', the current item passed on to the recipe is
    `None`.  All remaining positional and keyword arguments are passed
    on to the recipe as is.

    The decorated function can be invoked by passing the iterable
    (dataset) as the first argument, a True and False flag denoting
    whether the iteration should be done in infinite mode, and the
    final argument is a post iteration hoo; other arguments may follow
    these two.  The post iteration hook is a tuple where the first
    element is a callable, and the rest are any arguments it might
    expect

    iterable -- the dataset to iterate over
    inf      -- if true, run in infinite mode
    post     -- post iteration hook, it's a tuple with a callable,
                and expected arguments

    Example:

    >>> @iterate
    ... def proc_vector(vector, n, item, foo, bar='baz'):
    ...     # Sets all elements to 42
    ...     element = 42
    >>> proc_vector(vector, False, foo, bar='baz')  # normal
    >>> proc_vector(vector, True, foo, bar='baz')   # infinite

    """

    @wraps(recipe)
    def exec_recipe(iterable, inf, post, *args, **kwargs):
        if inf:
            try:
                niter = 0
                while True:
                    recipe(iterable, niter, None, *args, **kwargs)
                    niter += 1
                    if niter % len(iterable) == 0 and len(post):
                        call_hook(post)
            except KeyboardInterrupt:
                print(f"Stopped at iteration {niter:d}")
        else:
            for index, item in enumerate(iterable):
                recipe(iterable, index, item, *args, **kwargs)
            if len(post):
                call_hook(post)

    return exec_recipe
